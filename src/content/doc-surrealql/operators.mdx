---
sidebar_position: 3
sidebar_label: Operators
title: Operators | SurrealQL
description: A variety of operators in SurrealQL allow for complex manipulation of data, and advanced logic.
---

import Since from '@components/shared/Since.astro'
import Table from '@components/shared/Table.astro'

# Operators

A variety of operators in SurrealQL allow for complex manipulation of data, and advanced logic.

<Table>
	<thead>
		<tr>
			<th scope="col" class="w-48">Operator</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex gap-2">
					<a href="#and">
						<code>&&</code>
					</a>
					<a href="#and">
						<code>AND</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether both of two values are truthy
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex gap-2">
					<a href="#or">
						<code>||</code>
					</a>
					<a href="#or">
						<code>OR</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether either of two values is truthy
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#not">
					<code>!</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Reverses the truthiness of a value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#not_not">
					<code>!!</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Determines the truthiness of a value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#nco">
					<code>??</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Check whether either of two values are truthy and not NULL
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#tco">
					<code>?:</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Check whether either of two values are truthy
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex gap-2">
					<a href="#equal">
						<code>=</code>
					</a>
					<a href="#equal">
						<code>IS</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Check whether two values are equal
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex gap-2">
					<a href="#notequal">
						<code>!=</code>
					</a>
					<a href="#notequal">
						<code>IS NOT</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Check whether two values are not equal
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#exact">
					<code>==</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Check whether two values are exactly equal
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#anyequal">
					<code>?=</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Check whether any value in a set is equal to a value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#allequal">
					<code>*=</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Check whether all values in a set are equal to a value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#match">
					<code>~</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Compare two values for equality using fuzzy matching
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#match">
					<code>!~</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Compare two values for inequality using fuzzy matching
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#match">
					<code>?~</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Check whether any value in a set is equal to a value using
				fuzzy matching
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#match">
					<code>*~</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Check whether all values in a set are equal to a value using
				fuzzy matching
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#lessthan">
					<code>&lt;</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Check whether a value is less than another value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#lessthanorequal">
					<code>&lt;=</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Check whether a value is less than or equal to another value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#greaterthan">
					<code>&gt;</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Check whether a value is greater than another value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#greaterthanorequal">
					<code>&gt;=</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Check whether a value is greater than or equal to another
				value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#add">
					<code>+</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Add two values together
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#sub">
					<code>-</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Subtract a value from another value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex gap-2">
					<a href="#mul">
						<code>*</code>
					</a>
					<a href="#mul">
						<code>×</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Multiply two values together
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex gap-2">
					<a href="#div">
						<code>/</code>
					</a>
					<a href="#div">
						<code>÷</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Divide a value by another value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#pow">
					<code>**</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Raises a base value by another value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col gap-2">
					<a href="#contains">
						<code>CONTAINS</code>
					</a>
					<a href="#contains">
						<code>∋</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether a value contains another value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col gap-2">
					<a href="#containsnot">
						<code>CONTAINSNOT</code>
					</a>
					<a href="#containsnot">
						<code>∌</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether a value does not contain another value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col gap-2">
					<a href="#containsall">
						<code>CONTAINSALL</code>
					</a>
					<a href="#containsall">
						<code>⊇</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether a value contains all other values
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col gap-2">
					<a href="#containsany">
						<code>CONTAINSANY</code>
					</a>
					<a href="#containsany">
						<code>⊃</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether a value contains any other value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col gap-2">
					<a href="#containsnone">
						<code>CONTAINSNONE</code>
					</a>
					<a href="#containsnone">
						<code>⊅</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether a value contains none of the following values
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col items-start gap-2">
					<a href="#inside">
						<code>INSIDE</code>
					</a>
					<a href="#inside">
						<code>IN</code>
					</a>
					<a href="#inside">
						<code>∈</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether a value is contained within another value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col items-start gap-2">
					<a href="#notinside">
						<code>NOTINSIDE</code>
					</a>
					<a href="#notinside">
						<code>NOT IN</code>
					</a>
					<a href="#notinside">
						<code>∉</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether a value is not contained within another value
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col items-start gap-2">
					<a href="#allinside">
						<code>ALLINSIDE</code>
					</a>
					<a href="#allinside">
						<code>⊆</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether all values are contained within other values
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col items-start gap-2">
					<a href="#anyinside">
						<code>ANYINSIDE</code>
					</a>
					<a href="#anyinside">
						<code>⊂</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether any value is contained within other values
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col items-start gap-2">
					<a href="#noneinside">
					<code>NONEINSIDE</code>
					</a>
					<a href="#noneinside">
						<code>⊄</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether no value is contained within other values
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#outside">
					<code>OUTSIDE</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Checks whether a geometry type is outside of another
				geometry type
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<a href="#intersects">
					<code>INTERSECTS</code>
				</a>
			</td>
			<td scope="row" data-label="Description">
				Checks whether a geometry type intersects another geometry
				type
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col items-start gap-2">
					<a href="#matches">
						<code>@@</code>
					</a>
					<a href="#matches">
						<code>@[ref]@</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Checks whether the terms are found in a full-text indexed
				field
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Operator">
				<div class="flex flex-col items-start gap-2">
					<a href="#knn">
						<code> &lt;|4|&gt; </code>
					</a>
					<a href="#knn">
						<code>&lt;|3,HAMMING| &gt;</code>
					</a>
				</div>
			</td>
			<td scope="row" data-label="Description">
				Performs a K-Nearest Neighbors (KNN) search to find a
				specified number of records closest to a given data point,
				optionally using a defined distance metric. Supports
				customizing the number of results and choice of distance
				calculation method.
			</td>
		</tr>
	</tbody>
</Table>

## `&&` or `AND` {#and}

Checks whether both of two values are [truthy](/docs/surrealql/datamodel/values#values-and-truthiness).

```surql
/**
[test]

[[test.results]]
value = "30"

**/

SELECT * FROM 10 AND 20 AND 30;

-- 30
```

<br />

## `||` or `OR` {#or}

Checks whether either of two values are [truthy](/docs/surrealql/datamodel/values#values-and-truthiness).

```surql test
/**
[test]

[[test.results]]
value = "[10]"

**/

SELECT * FROM 0 OR false OR 10;

-- 10
```

<br />

## `!` {#not}

Reverses the truthiness of a value.

```surql
/**
[test]

[[test.results]]
value = "[false]"

[[test.results]]
value = "[false]"

**/

SELECT * FROM !(TRUE OR FALSE);
-- false

SELECT * FROM !"Has a value";
-- false
```

<br />

## `!!` {#not_not}

Determines the truthiness of a value (simply an application of the `!` operator twice).

```surql
/**
[test]

[[test.results]]
value = "[true]"

**/

SELECT * FROM !!"Has a value";
-- true
```

## `??` {#nco}

Check whether either of two values are [truthy](/docs/surrealql/datamodel/values#values-and-truthiness) and not `NULL`.

```surql
/**
[test]

[[test.results]]
value = "[0]"

**/

SELECT * FROM NULL ?? 0 ?? false ?? 10;

-- 0
```

<br />

## `?:` {#tco}

Check whether either of two values are [truthy](/docs/surrealql/datamodel/values#values-and-truthiness).

```surql
/**
[test]

[[test.results]]
value = "[10]"

**/

SELECT * FROM NULL ?: 0 ?: false ?: 10;

-- 10
```

<br />

## `=` or `IS` {#equal}

Check whether two values are equal.

```surql
/**
[test]

[[test.results]]
value = "[false]"

**/

SELECT * FROM true = "true";
-- false
```

```surql
/**
[test]

[[test.results]]
value = "[false]"

**/

SELECT * FROM 10 = "10";
-- false
```

```surql
/**
[test]

[[test.results]]
value = "[true]"

**/

SELECT * FROM 10 = 10.00;
-- true
```
```surql
/**
[test]

[[test.results]]
value = "[false]"

**/

SELECT * FROM 10 = "10.3";
-- false
```

```surql
/**
[test]

[[test.results]]
value = "[true]"

**/

SELECT * FROM [1, 2, 3] = [1, 2, 3];
-- true
```

```surql
/**
[test]

[[test.results]]
value = "[false]"

**/

SELECT * FROM [1, 2, 3] = [1, 2, 3, 4];
-- false
```

```surql
/**
[test]

[[test.results]]
value = "[true]"

**/

SELECT * FROM { this: "object" } = { this: "object" };
-- true
```

```surql
/**
[test]

[[test.results]]
value = "[false]"

**/

SELECT * FROM { this: "object" } = { another: "object" };
-- false
```

<br />

## `!=` or `IS NOT` {#notequal}

Check whether two values are equal.

```surql
/**
[test]

[[test.results]]
value = "[true]"

**/

SELECT * FROM 10 != "15";
-- true
```

```surql
/**
[test]

[[test.results]]
value = "[true]"

**/

SELECT * FROM 10 != "test";
-- true
```

```surql
/**
[test]

[[test.results]]
value = "[true]"

**/

SELECT * FROM [1, 2, 3] != [3, 4, 5];
-- true
```

<br />

## `==` {#exact}

Check whether two values are exact. This operator also checks that each value has the same type.

```surql
/**
[test]

[[test.results]]
value = "[true]"

**/

SELECT * FROM 10 == 10;
-- true
```

```surql
/**
[test]

[[test.results]]
value = "[false]"

**/

SELECT * FROM 10 == "10";
-- false
```

```surql
/**
[test]

[[test.results]]
value = "[false]"

**/

SELECT * FROM true == "true";
-- false
```

<br />

## `?=` {#anyequal}

Check whether any value in an array equals another value.

```surql
/**
[test]

[[test.results]]
value = "[true]"

**/

SELECT * FROM [10, 15, 20] ?= 10;
-- true
```

<br />

## `*=` {#allequal}

Check whether all values in an array equals another value.

```surql
/**
[test]

[[test.results]]
value = ""

**/

SELECT * FROM [10, 10, 10] *= 10;
-- true
```

<br />

## `~` `?~` `!~` `*~` {#match}

These operators used to compare two values for equality using fuzzy matching. They have been removed since 3.0 to avoid implicitly preferring one algorithm over another, as the type of fuzzy matching to use will depend on each individual case.

Please use the `string::similarity::*` functions instead:

```surql
/**
[test]

[[test.results]]
value = "NONE"

[[test.results]]
value = "true"

**/

let $threshold = 10;

string::similarity::smithwaterman("test text", "Test") > $threshold;
-- true
```

<br />

## `<` {#lessthan}

Check whether a value is less than another value.

```surql
/**
[test]

[[test.results]]
value = "[true]"

**/

SELECT * FROM 10 < 15;
-- true
```

<br />

## `<=` {#lessthanorequal}

Check whether a value is less than or equal to another value.

```surql
/**
[test]

[[test.results]]
value = "[true]"

**/

SELECT * FROM 10 <= 15;
-- true
```

<br />

## `>` {#greaterthan}

Check whether a value is less than another value.

```surql
/**
[test]

[[test.results]]
value = "[true]"

**/

SELECT * FROM 15 > 10;
-- true
```

<br />

## `>=` {#greaterthanorequal}

Check whether a value is less than or equal to another value.

```surql
/**
[test]

[[test.results]]
value = "[true]"

**/

SELECT * FROM 15 >= 10;
-- true
```

<br />

## `+` {#add}

Add two values together.

```surql
/**
[test]

[[test.results]]
value = "[20]"

**/

SELECT * FROM 10 + 10;
-- 20
```

```surql
/**
[test]

[[test.results]]
value = "['test this']"

**/

SELECT * FROM "test" + " " + "this";
-- "test this"
```

```surql
/**
[test]

[[test.results]]
value = "[13h30m]"

**/

SELECT * FROM 13h + 30m;
-- "13h30m"
```

<br />

## `-` {#sub}

Subtracts a value from another value.

```surql
/**
[test]

[[test.results]]
value = "[10]"

**/

SELECT * FROM 20 - 10;
-- 10
```

```surql
/**
[test]

[[test.results]]
value = "[1m]""

**/

SELECT * FROM 2m - 1m;
-- 1m
```

<br />

## `*` or `×` {#mul}

Multiplies a value by another value.

```surql
/**
[test]

[[test.results]]
value = "[40]"

**/

SELECT * FROM 20 * 2;
-- 40
```

<br />

## `/` or `÷` {#div}

Divides a value with another value.

```surql
/**
[test]

[[test.results]]
value = "[10]"

**/

SELECT * FROM 20 / 2;
-- 10
```

<br />

## `**` {#pow}

Raises a base value by another value.

```surql
/**
[test]

[[test.results]]
value = "[8000]"

**/

SELECT * FROM 20 ** 3;
-- 8000
```

<br />

## `CONTAINS` or `∋` {#contains}

Check whether a value contains another value.

```surql
/**
[test]

[[test.results]]
value = "[true]"

**/

SELECT * FROM [10, 20, 30] CONTAINS 10;
-- true
```
```surql
/**
[test]

[[test.results]]
value = ""

**/

SELECT * FROM "this is some text" CONTAINS "text";

true
```
```surql
/**
[test]

[[test.results]]
value = ""

**/

SELECT * FROM {
	type: "Polygon",
	coordinates: [[
		[-0.38314819, 51.37692386], [0.1785278, 51.37692386],
		[0.1785278, 51.61460570], [-0.38314819, 51.61460570],
		[-0.38314819, 51.37692386]
	]]
} CONTAINS (-0.118092, 51.509865);

true
```

<br />

## `CONTAINSNOT` or `∌` {#containsnot}

Check whether a value does not contain another value.

```surql
/**
[test]

[[test.results]]
value = ""

**/

SELECT * FROM [10, 20, 30] CONTAINSNOT 15;

true
```
```surql
/**
[test]

[[test.results]]
value = ""

**/

SELECT * FROM "this is some text" CONTAINSNOT "other";

true
```
```surql
/**
[test]

[[test.results]]
value = ""

**/

SELECT * FROM {
	type: "Polygon",
	coordinates: [[
		[-0.38314819, 51.37692386], [0.1785278, 51.37692386],
		[0.1785278, 51.61460570], [-0.38314819, 51.61460570],
		[-0.38314819, 51.37692386]
	]]
} CONTAINSNOT (-0.518092, 53.509865);

true
```

<br />

## `CONTAINSALL` or `⊇` {#containsall}

Check whether a value contains all of multiple values.

```surql
/**
[test]

[[test.results]]
value = ""

**/

SELECT * FROM [10, 20, 30] CONTAINSALL [10, 20, 10];

true
```

<br />

## `CONTAINSANY` or `⊃` {#containsany}

Check whether a value contains any of multiple values.

```surql
/**
[test]

[[test.results]]
value = ""

**/

SELECT * FROM [10, 20, 30] CONTAINSANY [10, 15, 25];

true
```

<br />

## `INSIDE` or `∈` or `IN` {#inside}

Check whether a value is contained within another value.

```surql
/**
[test]

[[test.results]]
value = ""

**/

SELECT * FROM 10 INSIDE [10, 20, 30];

true
```
```surql
/**
[test]

[[test.results]]
value = ""

**/

SELECT * FROM "text" INSIDE "this is some text";

true
```
```surql
/**
[test]

[[test.results]]
value = ""

**/

SELECT * FROM (-0.118092, 51.509865) INSIDE {
	type: "Polygon",
	coordinates: [[
		[-0.38314819, 51.37692386], [0.1785278, 51.37692386],
		[0.1785278, 51.61460570], [-0.38314819, 51.61460570],
		[-0.38314819, 51.37692386]
	]]
};

true
```

<Since v="v2.1.0" />

This operator can also be used to check for the existence of a key inside an [object](/docs/surrealql/datamodel/objects). To do so, precede `IN` with the field name as a string.

```surql
/**
[test]

[[test.results]]
value = ""

**/

"name" IN {
    name: "Riga",
    country: "Latvia"
};

-- true
```

`IN` can also be used with a record ID as long as the ID is expanded to include the fields. Both of the following queries will return `true`.

```surql
/**
[test]

[[test.results]]
value = ""

**/

CREATE city:riga SET name = "Riga", country = "Latvia", population = 605273;

"name" IN city:riga.*;
"name" IN city:riga.{ name, country };
```

<br />

## `NOTINSIDE` or `∉` or `NOT IN` {#notinside}

Check whether a value is not contained within another value.

```surql
/**
[test]

[[test.results]]
value = ""

**/

SELECT * FROM 15 NOTINSIDE [10, 20, 30];

true
```
```surql
/**
[test]

[[test.results]]
value = ""

**/

SELECT * FROM "other" NOTINSIDE "this is some text";

true
```
```surql
/**
[test]

[[test.results]]
value = ""

**/

SELECT * FROM (-0.518092, 53.509865) NOTINSIDE {
	type: "Polygon",
	coordinates: [[
		[-0.38314819, 51.37692386], [0.1785278, 51.37692386],
		[0.1785278, 51.61460570], [-0.38314819, 51.61460570],
		[-0.38314819, 51.37692386]
	]]
};

true
```

<br />

## `ALLINSIDE` or `⊆` {#allinside}

Check whether all of multiple values are contained within another value.

```surql
/**
[test]

[[test.results]]
value = ""

**/

SELECT * FROM [10, 20, 10] ALLINSIDE [10, 20, 30];

true
```

<br />

## `ANYINSIDE` or `⊂` {#anyinside}

Check whether any of multiple values are contained within another value.

```surql
/**
[test]

[[test.results]]
value = ""

**/

SELECT * FROM [10, 15, 25] ANYINSIDE [10, 20, 30];

true
```

<br />

## `NONEINSIDE` or `⊄` {#noneinside}

Check whether none of multiple values are contained within another value.

```surql
/**
[test]

[[test.results]]
value = ""

**/

SELECT * FROM [15, 25, 35] NONEINSIDE [10, 20, 30];

true
```

<br />

## `OUTSIDE` {#outside}
Check whether a geometry value is outside another geometry value.

```surql
/**
[test]

[[test.results]]
value = ""

**/

SELECT * FROM (-0.518092, 53.509865) OUTSIDE {
	type: "Polygon",
	coordinates: [[
		[-0.38314819, 51.37692386], [0.1785278, 51.37692386],
		[0.1785278, 51.61460570], [-0.38314819, 51.61460570],
		[-0.38314819, 51.37692386]
	]]
};

true
```

<br />

## `INTERSECTS` {#intersects}
Check whether a geometry value intersects another geometry value.

```surql
/**
[test]

[[test.results]]
value = ""

**/

SELECT * FROM {
	type: "Polygon",
	coordinates: [[
		[-0.38314819, 51.37692386], [0.1785278, 51.37692386],
		[0.1785278, 51.61460570], [-0.38314819, 51.61460570],
		[-0.38314819, 51.37692386]
	]]
} INTERSECTS {
	type: "Polygon",
	coordinates: [[
		[-0.11123657, 51.53160074], [-0.16925811, 51.51921169],
		[-0.11466979, 51.48223813], [-0.07381439, 51.51322956],
		[-0.11123657, 51.53160074]
	]]
};

true
```

<br />

## `MATCHES` {#matches}

Checks whether the terms are found in a full-text indexed field.

```surql
/**
[test]

[[test.results]]
value = ""

**/

SELECT * FROM book WHERE title @@ 'rust web';


[
	{
		id: book:1,
		title: 'Rust Web Programming'
	}
]

```
Using the matches operator with a reference checks whether the terms are found, highlights the searched terms, and computes the full-text score.

```surql
/**
[test]

[[test.results]]
value = ""

**/

SELECT id,
		search::highlight('<b>', '</b>', 1) AS title,
		search::score(1) AS score
FROM book
WHERE title @1@ 'rust web'
ORDER BY score DESC;

[
	{
		id: book:1,
		score: 0.9227996468544006f,
		title: '<b>Rust</b> <b>Web</b> Programming'
	}
]
```

<Since v="v3.0.0-alpha.8" />

### `AND`, `OR`, and numeric operators inside `@@`

The keywords `AND` and can be included inside the matches operator, while the keyword `OR` can also be used if an index is defined with the `FULLTEXT ANALYZER` clause instead of the `SEARCH ANALYZER` clause.

```surql
/**
[test]

[[test.results]]
value = ""

**/

CREATE document:1 SET text = "It is rare that I find myself penning a personal note in my chronicles.";
DEFINE ANALYZER simple TOKENIZERS blank,class FILTERS lowercase;
DEFINE INDEX some_index ON document FIELDS text FULLTEXT ANALYZER simple BM25;
```

Manually using `AND` and `OR` outside of the matches operator has always been possible. Both of these queries will return `document:1` because both words match in the first case using `AND`, and one matches in the second case using `OR`.

```surql
/**
[test]

[[test.results]]
value = ""

**/

SELECT id FROM document WHERE text @@ 'PERSONAL' AND text @@ 'INCLUSION';
SELECT id FROM document WHERE text @@ 'PERSONAL' OR text @@ 'cat';
```

## `KNN`

<Since v="v1.3.0" />

K-Nearest Neighbors (KNN) is a fundamental algorithm used for classifying or regressing based on the closest data points in the feature space, with its performance and scalability critical in applications involving large datasets.

In practice, the efficiency and scalability of the KNN algorithm are crucial, especially when dealing with large datasets. Different implementations of KNN are tailored to optimize these aspects without compromising the accuracy of the results.

SurrealDB supports different K-Nearest Neighbors methods to perform KNN searches, each with unique requirements for syntax.
Below are the details for each method, including how to format your query with examples:

### Brute Force Method

Best for smaller datasets or when the highest accuracy is required.

```syntax title="SurrealQL Syntax"
<|K,DISTANCE_METRIC|>
```

- K: The number of nearest neighbors to retrieve.
- DISTANCE_METRIC: The metric used to calculate distances, such as EUCLIDEAN or MANHATTAN.

```surql
/**
[test]

[[test.results]]
value = ""

**/

CREATE pts:3 SET point = [8,9,10,11];
SELECT id FROM pts WHERE point <|2,EUCLIDEAN|> [2,3,4,5];
```

### MTREE Index Method

<Since v="v1.3.0" />

Ideal for larger datasets where performance is crucial, and a consistent distance metric can be predefined.

```syntax title="SurrealQL Syntax"
<|K|>
```

- K: The number of nearest neighbors. The distance metric is predefined in the index, simplifying the syntax.

```surql
/**
[test]

[[test.results]]
value = ""

**/

CREATE pts:3 SET point = [8,9,10,11];
DEFINE INDEX mt_pts ON pts FIELDS point MTREE DIMENSION 4 DIST EUCLIDEAN;
SELECT id FROM pts WHERE point <|2|> [2,3,4,5];
```

### HNSW Method

<Since v="v1.5.0" />

Recommended for very large datasets where speed is essential and some loss of accuracy is acceptable.

```syntax title="SurrealQL Syntax"
<|K,EF|>
```

- K: The number of nearest neighbors.
- EF: The size of the dynamic candidate list during the search, affecting the search's accuracy and speed.

```surql
/**
[test]

[[test.results]]
value = ""

**/

CREATE pts:3 SET point = [8,9,10,11];
DEFINE INDEX mt_pts ON pts FIELDS point HNSW DIMENSION 4 DIST EUCLIDEAN EFC 150 M 12;
SELECT id FROM pts WHERE point <|10,40|> [2,3,4,5];
```
<br /><br />

## Types of operators, order of operations and binding power

To determine which operator is executed first, a concept called "binding power" is used. Operators with greater binding power will operate directly on their neighbours before those with lower binding power. The following is a list of all operator types from greatest to lowest binding power.

<Table>
	<thead>
		<tr>
			<th scope="col" class="w-40">Operator name</th>
			<th scope="col">Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row" data-label="Type">
				`Unary`
			</td>
			<td scope="row" data-label="Description">
				The `Unary` operators are `!`, `+`, and `-`.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				`Nullish`
			</td>
			<td scope="row" data-label="Description">
				The `Nullish` operators are `?:` and `??`.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				`Range`
			</td>
			<td scope="row" data-label="Description">
				The `Range` operator is `..`.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				`Cast`
			</td>
			<td scope="row" data-label="Description">
				The `Cast` operator is `<type_name>`, with `type_name` a stand in for the type to cast into. For example, `<string>` or `<number>`.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				`Power`
			</td>
			<td scope="row" data-label="Description">
				The only `Power` operator is `**`.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				`MulDiv`
			</td>
			<td scope="row" data-label="Description">
				The `MulDiv` (multiplication and division) operators are `*`, `/`, `÷`, and `%`.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				`AddSub`
			</td>
			<td scope="row" data-label="Description">
				The `AddSub` (addition and subtraction) operators are `+` and `-`.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				`Relation`
			</td>
			<td scope="row" data-label="Description">
				The `Relation` operators are `<=`, `>=`, `∋`, `CONTAINS`, `∌`, `CONTAINSNOT`, `∈`, `INSIDE`, `∉`, `NOTINSIDE`, `⊇`, `CONTAINSALL`, `⊃`, `CONTAINSANY`, `⊅`, `CONTAINSNONE`, `⊆`, `ALLINSIDE`, `⊂`, `ANYINSIDE`, `⊄`, `NONEINSIDE`, `OUTSIDE`, `INTERSECTS`, `NOT`, and `IN`.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				`Equality`
			</td>
			<td scope="row" data-label="Description">
				The `Equality` operators are `=`, `IS`, `==`, `!=`, `*=`, `?=`, and `@`.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				`And`
			</td>
			<td scope="row" data-label="Description">
				The `And` operators are `&&` and `AND`.
			</td>
		</tr>
		<tr>
			<td scope="row" data-label="Type">
				`Or`
			</td>
			<td scope="row" data-label="Description">
				The `Or` operators are `||` and `OR`.
			</td>
		</tr>
	</tbody>
</Table>

## Examples of binding power

The following samples show examples of basic operations of varying binding power. The original example is followed by the same example with the parts with higher binding power in parentheses, then the final expression after the first bound portion is calculated, and finally the output.

```surql
/**
[test]

[[test.results]]
value = ""

**/
 title="MulDiv first, then AddSub"
1 + 3 * 4;
1 + (3 * 4);
-- Final expression
1 + 12;
-- Output
13
```

```surql
/**
[test]

[[test.results]]
value = ""

**/
 title="Power first, then MulDiv"
2**3 * 3;
(2**3) * 3;
-- Final expression
8*3;
-- Output
24
```

```surql
/**
[test]

[[test.results]]
value = ""

**/
 title="Unary first, then cast"
<string>-4;
<string>(-4);
-- Output
"-4"
```

```surql
/**
[test]

[[test.results]]
value = ""

**/
 title="Cast first, then Power"
<number>"9"**9;
(<number>"9")**9;
-- Final expression
9**9;
-- Output
387420489
```

```surql
/**
[test]

[[test.results]]
value = ""

**/
 title="AddSub first, then Relation"
"c" + "at" IN "cats";
("c" + "at") IN "cats";
-- Final expression
"cat" IN "cats";
-- Output
true
```

```surql
/**
[test]

[[test.results]]
value = ""

**/
 title="And first, then Or"
true AND false OR true;
(true AND false) OR true;
-- Final expression
false OR true;
-- Output
true
```

```surql
/**
[test]

[[test.results]]
value = ""

**/
 title="Unary, then Cast, then Power, then AddSub"
<decimal>-4**2+4;
((<decimal>(-4))**2)+4;
-- Output
20
```

## $param = value

If the database encounters a statement composed of a parameter name followed by `=` and a value, it will be considered to be part of a `LET` statement as opposed to the equality operator.

```surql
/**
[test]

[[test.results]]
value = ""

**/

$name = "Trevor";
-- Binds "Trevor" to $name and returns `NONE`
-- Does not return `true`
$name = "Trevor";
```

To compare for equality in this case, the statement order can be reversed or the `==` operator can be used.

```surql
/**
[test]

[[test.results]]
value = ""

**/

$name = "Trevor";
-- Both return `true`
"Trevor" = $name;
$name == "Trevor";
```

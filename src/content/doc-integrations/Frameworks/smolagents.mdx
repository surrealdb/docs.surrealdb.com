---
sidebar_position: 1
sidebar_label: Smolagents
title: SmolAgents— Grocery Finder
description: A complete walkthrough for building a code-generating AI agent that recommends grocery items by querying SurrealDB’s HNSW vector index.
---

# Smolagents

In this guide you will build an agent that, given a natural-language shopping request, finds the most relevant grocery items in your database and returns them in a single reply.

## Install the dependencies

```bash
pip install smolagents surrealdb fastembed datasets
````

| Library        | Purpose                                |
| -------------- | -------------------------------------- |
| **surrealdb**  | Async Python SDK for SurrealDB         |
| **smolagents** | Code-generating agent framework        |
| **fastembed**  | Local Jina v2 embedding model (768-D)  |
| **datasets**   | Pulls the public *GroceryList* dataset |

## Create a SurrealDB “grocery search” tool

```python
from fastembed import TextEmbedding
from surrealdb import Surreal
from smolagents import Tool
from datasets import load_dataset
import asyncio, os

class GroceryQueryTool(Tool):
    name = "surreal_grocery_search"
    description = "Semantic search over grocery items stored in SurrealDB."
    inputs = {
        "query": {
            "type": "string",
            "description": "A natural-language description of a grocery need.",
        }
    }
    output_type = "string"


    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # Connection details
        self.uri    = "http://localhost:8000/rpc"
        self.ns     = "demo"
        self.dbname = "demo"
        self.table  = "groceries"
        self.user   = os.getenv("SURREAL_USER", "root")
        self.pw     = os.getenv("SURREAL_PASS", "root")

        self.db  = Surreal(self.uri)
        self.emb = TextEmbedding(model_name="jinaai/jina-embeddings-v2-base-en")

        # one-time async bootstrap
        asyncio.run(self._setup())


    async def _setup(self):
        """Connect, create schema, and ingest groceries if empty."""
        await self.db.signin({"user": self.user, "pass": self.pw})
        await self.db.use(self.ns, self.dbname)

        schema = """
        DEFINE TABLE $tb SCHEMALESS PERMISSIONS NONE;
        DEFINE FIELD item_name   ON $tb TYPE string;
        DEFINE FIELD category    ON $tb TYPE string;
        DEFINE FIELD description ON $tb TYPE string;
        DEFINE FIELD embedding   ON $tb TYPE array;

        DEFINE INDEX idx_hnsw ON $tb
          FIELDS embedding
          HNSW DIMENSION 768
          DIST   COSINE;
        """
        await self.db.query(schema, {"tb": self.table})  /* variable binding */citeturn2search0

        # skip ingest if we already have rows
        existing = await self.db.query(f"SELECT count() FROM {self.table};")
        if existing[0].result[0]["count"] > 0:
            return

        print("🛒 Ingesting GroceryList dataset …")
        ds = load_dataset("AmirMohseni/GroceryList")["train"]  /* 225 rows */citeturn1view0

        BATCH = 64
        items  = ds["item"]
        cats   = ds["category"]
        descs  = [f"{it.capitalize()} is in the {cat} aisle." for it, cat in zip(items, cats)]

        for i in range(0, len(descs), BATCH):
            vecs = self.emb.query_embed(descs[i:i+BATCH])
            rows = [
                {
                    "id":          f"{self.table}:{i+j}",
                    "item_name":   items[i+j],
                    "category":    cats[i+j],
                    "description": descs[i+j],
                    "embedding":   list(vec),
                }
                for j, vec in enumerate(vecs)
            ]
            await self.db.query(f"INSERT INTO {self.table} $data", {"data": rows})


    def forward(self, query: str) -> str:
        """Return the five closest grocery items."""
        q_vec = next(self.emb.query_embed(query))

        surql = """
        LET $q := $vec;
        SELECT item_name, category, description,
               vector::distance::knn() AS dist
        FROM $tb
        WHERE embedding <|5,64|> $q      -- top-5, efSearch=64
        ORDER BY dist;
        """
        async def _lookup():
            res = await self.db.query(surql, {"vec": q_vec, "tb": self.table})
            return res[0].result
        hits = asyncio.run(_lookup())

        return "Retrieved items:\n" + "".join(
            f"== {hit['item_name'].title()} ==\n"
            f"Category: {hit['category']}\n"
            f"{hit['description']}\n\n"
            for hit in hits
        )
```

**Key SurrealDB bits**

* `DEFINE INDEX … HNSW` activates the **approx-nearest-neighbour** index
* `<|K,EF|>` in the query performs the K-NN lookup with `K=5`, `efSearch=64`

## Create a code-generating agent

```python
from smolagents import CodeAgent, HfApiModel
import os

os.environ["HF_TOKEN"] = "…"        # your Hugging Face token

agent = CodeAgent(
    tools=[GroceryQueryTool()],
    model=HfApiModel(),             # Claude-3 Sonnet by default
    max_iterations=4,
    verbose=True,
)
```

## Run the agent

```python
answer = agent.run("Healthy green leafy vegetable rich in iron")
print(answer)
```

Typical output:

```
== Spinach ==
Category: Produce
Spinach is in the Produce aisle.

== Kale ==
Category: Produce
Kale is in the Produce aisle.

Final answer: Spinach
```

## Further Reading

* [SurrealDB vector-search guide](/docs/surrealql/statements/define/indexes)
* [SmolAgents on GitHub](https://github.com/huggingface/smolagents)
* [FastEmbed](https://github.com/qdrant/fastembed) — local embedding models


---
sidebar_position: 1
sidebar_label: Upgrading from 2.x to 3.x
title: Upgrading from 2.x to 3.x | Upgrading | Installation
description: This guide will help you upgrade your current SurrealDB installation to the latest `3.x` release.
---

import Image from "@components/Image.astro";
import SurrealistMigrationDiagnostics from "@img/image/dark/migration-diagnostics.png";
import SurrealistMigrationReport from "@img/image/dark/surrealist-migration-report.png";

# Upgrading from `2.x` to `3.x` 

This guide consolidates all breaking changes when upgrading from SurrealDB `2.x` to `3.x`, organised by severity level. If you are using Surrealist, you can use the [migration diagnostics](/docs/surrealist) to automatically see your data. This will also provide you with a list of actions you need to take to migrate your data.

## Migration diagnostics in Surrealist

Surrealist provides a built-in migration diagnostics tool that can be used to automatically see your data and provide you with a list of actions you need to take to migrate your data.

<Image
alt="Surrealist migration diagnostics"
src={{
	light: SurrealistMigrationDiagnostics,
	dark: SurrealistMigrationDiagnostics,
}}
/>

Select your `2.x` database and click on the **Migration** option in the sidebar. This will open the migration diagnostics tool. First you'll need to start the checks by clicking on the **Start Checks** button. This will return a migration report with a list of actions you need to take to migrate your data (If any).

<Image
alt="Surrealist migration report"
src={{
	light: SurrealistMigrationReport,
	dark: SurrealistMigrationReport,
}}
/>

After resolving the issue, click on the **Mark as resolved** button to mark the issue as resolved. This will remove the issue from the migration report.

## Severity Levels

In this section, we will explore the different severity levels of the migration report and the actions you need to take to migrate your data. These severity levels are as follows:

- **Will break**: Almost guaranteed to change query semantics when porting to `3.x`
- **Can break**: Some use cases will remain the same, but likely to cause issues
- **Unlikely break**: Only affects edge cases or rare usage patterns

## Will Break - Critical Changes

### 1. Futures Replaced with COMPUTED Fields

**Severity**: Will break

**What Changed**: The `<future>` type has been completely removed and replaced with `COMPUTED` fields.

**Migration Actions**:
1. Use the migration tool to automatically convert futures where possible
2. Manually replace `VALUE <future> { expression }` with `COMPUTED expression`
3. Restructure code for cases where automatic conversion isn't possible (nested fields, DEFAULT futures)

**Before (2.x)**:
```surql
DEFINE FIELD age ON person VALUE <future> { time::year(time::now()) - time::year(born) };
CREATE foo SET field = <future> { expression };
```

**After (3.x)**:
```surql
DEFINE FIELD age ON person COMPUTED time::year(time::now()) - time::year(born);
-- Futures stored in records cannot be converted - requires redesign
```

>[!NOTE]
>For futures stored in records (using `DEFAULT <future>` or `CREATE ... SET field = <future>`), there is no direct replacement in `3.x`. Fixing these cases will require re-architecting your schema, as storing arbitrary queries in record data is no longer supported.

**COMPUTED Restrictions**:

- Can only be used in `DEFINE FIELD` statements
- No nested fields allowed inside or under COMPUTED fields
- Cannot be used on ID fields
- Cannot combine with: `VALUE`, `DEFAULT`, `READONLY`, `ASSERT`, `REFERENCE`, `FLEXIBLE`
- Only works on top-level fields, not nested fields

**Example - Nested Field Workaround**:

```surql
-- 2.x version
DEFINE FIELD name.full ON person VALUE <future> { name.first + ' ' + name.last };

-- 3.x version - must rename to avoid nesting
DEFINE FIELD full_name ON person COMPUTED name.first + ' ' + name.last;
```

### 2. Function Name Changes

**Severity**: Will break

**Action**: Update all function names according to the mapping table below.

**Reason for Changes**:
- `::is::` and `::from::` → `::is_` and `::from_` (matches method syntax)
- `thing` → `record` (consistent terminology)
- `rand::guid()` → `rand::id()` (default record ID format)
- `string::distance::osa_distance` → `string::distance::osa` (remove redundancy)

**Complete Mapping Table**:

| New Function Name | Previous Name |
|-------------------|---------------|
| `duration::from_days` | `duration::from::days` |
| `duration::from_hours` | `duration::from::hours` |
| `duration::from_micros` | `duration::from::micros` |
| `duration::from_millis` | `duration::from::millis` |
| `duration::from_mins` | `duration::from::mins` |
| `duration::from_nanos` | `duration::from::nanos` |
| `duration::from_secs` | `duration::from::secs` |
| `duration::from_weeks` | `duration::from::weeks` |
| `rand::id` | `rand::guid` |
| `string::distance::osa` | `string::distance::osa_distance` |
| `string::is_alphanum` | `string::is::alphanum` |
| `string::is_alpha` | `string::is::alpha` |
| `string::is_ascii` | `string::is::ascii` |
| `string::is_datetime` | `string::is::datetime` |
| `string::is_domain` | `string::is::domain` |
| `string::is_email` | `string::is::email` |
| `string::is_hexadecimal` | `string::is::hexadecimal` |
| `string::is_ip` | `string::is::ip` |
| `string::is_ipv4` | `string::is::ipv4` |
| `string::is_ipv6` | `string::is::ipv6` |
| `string::is_latitude` | `string::is::latitude` |
| `string::is_longitude` | `string::is::longitude` |
| `string::is_numeric` | `string::is::numeric` |
| `string::is_semver` | `string::is::semver` |
| `string::is_url` | `string::is::url` |
| `string::is_ulid` | `string::is::ulid` |
| `string::is_uuid` | `string::is::uuid` |
| `string::is_record` | `string::is::record` |
| `time::from_micros` | `time::from::micros` |
| `time::from_millis` | `time::from::millis` |
| `time::from_nanos` | `time::from::nanos` |
| `time::from_secs` | `time::from::secs` |
| `time::from_ulid` | `time::from::ulid` |
| `time::from_unix` | `time::from::unix` |
| `time::from_uuid` | `time::from::uuid` |
| `time::is_leap_year` | `time::is::leap_year` |
| `type::record` | `type::thing` |
| `type::is_array` | `type::is::array` |
| `type::is_bool` | `type::is::bool` |
| `type::is_bytes` | `type::is::bytes` |
| `type::is_collection` | `type::is::collection` |
| `type::is_datetime` | `type::is::datetime` |
| `type::is_decimal` | `type::is::decimal` |
| `type::is_duration` | `type::is::duration` |
| `type::is_float` | `type::is::float` |
| `type::is_geometry` | `type::is::geometry` |
| `type::is_int` | `type::is::int` |
| `type::is_line` | `type::is::line` |
| `type::is_multiline` | `type::is::multiline` |
| `type::is_multipoint` | `type::is::multipoint` |
| `type::is_multipolygon` | `type::is::multipolygon` |
| `type::is_none` | `type::is::none` |
| `type::is_null` | `type::is::null` |
| `type::is_number` | `type::is::number` |
| `type::is_object` | `type::is::object` |
| `type::is_point` | `type::is::point` |
| `type::is_polygon` | `type::is::polygon` |
| `type::is_range` | `type::is::range` |
| `type::is_record` | `type::is::record` |
| `type::is_string` | `type::is::string` |
| `type::is_uuid` | `type::is::uuid` |


### 3. array::range Argument Changes

**Severity**: Will break

**What Changed**: Arguments changed from `(offset, count)` to `(start, end)` or accepting a range.

**Action**: Change all `array::range` calls to use start/end bounds instead of offset/count.

**Before (2.x)**:
```surql
array::range(0, 5)   // returns [0,1,2,3,4]
array::range(-1, 5)  // returns [-1,0,1,2,3]
array::range(-5, 5)  // returns [-5,-4,-3,-2,-1]
```

**After (3.x)**:
```surql
array::range(0, 5)   // returns [0,1,2,3,4]
array::range(-1, 5)  // returns [-1,0,1,2,3,4]  ← different!
array::range(-5, 5)  // returns [-5,-4,-3,-2,-1,0,1,2,3,4]  ← different!
array::range(0..=1)  // returns [0,1]
```

**Migration Formula**: 
- Old: `array::range(offset, count)`
- New: `array::range(offset, offset + count)`


### 4. LET Required for Parameters

**Severity**: Will break

**What Changed**: Parameter declarations now require `LET` keyword.

**Action**: Add `LET` before all parameter declarations.

**Before (2.x)**:
```surql
$val = 10;  // This was allowed
```

**After (3.x)**:
```surql
LET $val = 10;  // LET is now required
```

**Error Message**:
```
Parse error: Parameter declarations without `let` are deprecated.
Replace with `let $val = ...` to keep the previous behavior.
```


### 5. GROUP and SPLIT Cannot Be Used Together

**Severity**: Will break

**What Changed**: Using both `GROUP` and `SPLIT` in the same query is no longer allowed.

**Action**: Put either `GROUP` or `SPLIT` into a subquery.

**Before (2.x)**:
```surql
SELECT age, emails FROM user SPLIT emails GROUP BY age;
```

**After (3.x) - Option 1 (split then group)**:
```surql
SELECT age, emails FROM (SELECT * FROM user SPLIT emails) GROUP BY age;
```

**After (3.x) - Option 2 (group then split)**:
```surql
SELECT * FROM (SELECT age, emails FROM user GROUP BY age, emails) SPLIT emails;
```

### 6. Like Operators Removed

**Severity**: Will break

**What Changed**: The `~`, `!~`, `?~`, `*~` operators have been removed.

**Action**: Replace with `string::distance` or `string::similarity` functions.

**Reason**: Multiple similarity algorithms now available; users should choose their own cutoff point.

**Before (2.x)**:
```surql
"Mario" ~ "mario";  // returns true
```

**After (3.x)**:
```surql
string::similarity::jaro("Mario", "mario") > 0.8;  // returns true

-- Create reusable function
DEFINE FUNCTION fn::similar($one: string, $two: string) -> bool {
    string::similarity::jaro($one, $two) > 0.8
};

fn::similar("Mario", "mario");  // returns true
```

**Available Functions**:
- `string::similarity::jaro()`
- `string::distance::osa()`
- And other similarity/distance functions


### 7. SEARCH ANALYZER → FULLTEXT ANALYZER

**Severity**: Will break

**Action**: Replace all instances of `SEARCH ANALYZER` with `FULLTEXT ANALYZER`.

**Before (2.x)**:
```surql
DEFINE INDEX userNameIndex ON TABLE user 
COLUMNS name SEARCH ANALYZER example_ascii BM25 HIGHLIGHTS;
```

**After (3.x)**:
```surql
DEFINE INDEX userNameIndex ON TABLE user 
COLUMNS name FULLTEXT ANALYZER example_ascii BM25 HIGHLIGHTS;
```

### 8. Database-Level Strictness

**Severity**: Will break (if using --strict flag)

**What Changed**: Strictness moved from instance-level flag to database-level definition.

**Action**: Add `STRICT` to `DEFINE DATABASE` statements for databases that need strictness.

**Before (2.x)**:
```bash
surreal start --strict
```

**After (3.x)**:
```surql
DEFINE DATABASE mydb STRICT;
```

**Impact**: Allows different databases on the same instance to have different strictness levels.


### 9. MTREE Removal

**Severity**: Will break

**What Changed**: `MTREE` vector search has been removed.

**Action**: Use `HNSW` instead of `MTREE` in index definitions.

**Before (2.x)**:
```surql
DEFINE INDEX vec_idx ON table FIELDS embedding MTREE DIMENSION 768;
```

**After (3.x)**:
```surql
DEFINE INDEX vec_idx ON table FIELDS embedding HNSW DIMENSION 768;
```


## Can Break - Likely Issues

### 10. All Idiom `.*` Behavior

**Severity**: Can break

**What Changed**: `.*` behavior changed for arrays and objects.

**Breaks When**: Used to dereference record IDs in arrays or get object values.

**Before (2.x)**:
```surql
[a:1, a:2].*       // returns [a:1, a:2]
[a:1, a:2].*.*     // dereferences records
{ a: 1, b: "foo" }.* // returns [1, "foo"]
```

**After (3.x)**:
```surql
[a:1, a:2].*       // dereferences records directly
{ a: 1, b: "foo" }.* // returns { a: 1, b: "foo" }
```

**Migration**:
- For arrays: Replace `.*.*` with `.*`
- For objects: Replace `.*` with `object::values()` function


### 11. Field Idiom Followed by Another Idiom Part

**Severity**: Can break

**What Changed**: Field idioms on arrays now work on individual elements instead of the whole array.

**Breaks When**: Field idiom on array of objects is followed by another idiom part.

**Before (2.x)**:
```surql
[{ a: ["a","b"]}, {a: [1,2]}].a[0]
// returns ["a","b"]
// Evaluated as: ([...].a)[0]
```

**After (3.x)**:
```surql
[{ a: ["a","b"]}, {a: [1,2]}].a[0]
// returns ["a",1]
// Evaluated on each element: [(...).a[0], (...).a[0]]
```

**Migration**: Swap idiom parts if old behavior needed.
- Old: `.field[0]`
- New: `[0].field`


### 12. Idiom Fetching Changes

**Severity**: Can break

**What Changed**: Multiple improvements to idiom fetching behavior.

**Quick Reference Table**:

| Example | 2.x Output | 3.x Output |
|---------|------------|------------|
| `[1, a:1].*` | `[1, a:1]` | `[1, { id: a:1 }]` |
| `[1, a:1].*.*` | `[NONE, { id: a:1 }]` | `[NONE, { id: a:1 }]` |
| `a:1.*` | `{ id: a:1 }` | `{ id: a:1 }` |
| `{ key: 123 }.*` | `[123]` | `{ key: 123 }` |
| `a:1<-edge[0]` | `{ id: edge:1 }` | `edge:1` |
| `[{ n: 1 }, { n: 2 }].n[0]` | `1` | `[NONE, NONE]` |

**Action**: Review queries using these idioms and rewrite if necessary.


### 13. Optional Parts Syntax Change

**Severity**: Can break

**What Changed**: Optional operator changed from `?` to `.?`

**Action**: Replace `?` with `.?` after optional values.

**Before (2.x)**:
```surql
["string", NONE].map(|$val| $val?.len());
```

**After (3.x)**:
```surql
["string", NONE].map(|$val| $val.?.len());
```

**Reason**: Distinguishes between `??` operator and optional chaining on `option<option<value>>`.


### 14. Parsing Changes

**Severity**: Can break

**Record ID Parsing**:
```surql
-- 2.x
r"a:b[r"c:d"]"  // unescaped " was allowed

-- 3.x
r"a:b[r\"c:d\"]"  // must escape "
```

**Unicode Parsing**:
```surql
-- 2.x
"\uD83D\uDF15"  // surrogate pairs

-- 3.x
"\u{1F715}"  // single escape sequence
```

**Identifier Escaping**: Escaped identifiers now support escape sequences like `\n`, `\u{AB1234}`.


### 15. New Set Type Behavior

**Severity**: Can break

**What Changed**: Set type now both deduplicates AND orders items, displays with `{}` instead of `[]`.

**Before (2.x)**:
```surql
<set>[2,3,1,1];  // returns [2, 3, 1]
```

**After (3.x)**:
```surql
<set>[2,3,1,1];  // returns {1, 2, 3}
```

**Migration Options**:
1. Use new set type (recommended)
2. Maintain old behavior: Add `VALUE $value.distinct()` to `DEFINE FIELD` definition


### 16. Schema Strictness Changes

**Severity**: Can break

**Non-Existing Tables**:
```surql
-- 3.x returns errors instead of empty arrays
SELECT * FROM doesnt_exist;
-- Error: "The table 'doesnt_exist' does not exist"
```

**SCHEMAFULL Tables**:
```surql
DEFINE TABLE user SCHEMAFULL;
DEFINE FIELD name ON user TYPE string;

-- 2.x: extra fields silently filtered
-- 3.x: extra fields cause error
CREATE user CONTENT { name: "Billy", other: "value" };
-- Error: "Found field 'other', but no such field exists"

-- Use destructuring to select only defined fields
CREATE user CONTENT { name: "Billy", other: "value" }.{ name };
```

## Unlikely Break - Edge Cases

### 17. math::sqrt Returns NaN

**Severity**: Unlikely break

**What Changed**: Returns `NaN` instead of `NONE` for negative numbers.

**Action**: Change checks from `NONE` to `NaN`.

```surql
-- 2.x
math::sqrt(-1);  // returns NONE

-- 3.x
math::sqrt(-1);  // returns NaN
```


### 18. math::min Returns Infinity

**Severity**: Unlikely break

**What Changed**: Returns `Infinity` instead of `NONE` for empty arrays.

**Action**: Change checks from `NONE` to `Infinity`.

```surql
-- 2.x
math::min([]);  // returns NONE

-- 3.x
math::min([]);  // returns Infinity
```


### 19. math::max Returns -Infinity

**Severity**: Unlikely break

**What Changed**: Returns `-Infinity` instead of `NONE` for empty arrays.

**Action**: Change checks from `NONE` to `-Infinity`.

```surql
-- 2.x
math::max([]);  // returns NONE

-- 3.x
math::max([]);  // returns -Infinity
```


### 20. array::logical_and Behavior

**Severity**: Unlikely break

**What Changed**: Function now consistent with `&&` operator.

**Breaks When**: Relying on specific values rather than truthiness.

**Before (2.x)**:
```surql
array::logical_and(["a"],[true]);  // returns ["a"]
array::logical_and([""],[false]);  // returns [""]
array::logical_and([true],[]);     // returns [NULL]
```

**After (3.x)**:
```surql
array::logical_and(["a"],[true]);  // returns [true]
array::logical_and([""],[false]);  // returns [""]
array::logical_and([true],[]);     // returns [NONE]
```

**Action**: Update if relying on specific return values; no change needed if only checking truthiness.


### 21. array::logical_or Behavior

**Severity**: Unlikely break

**What Changed**: Function now consistent with `||` operator.

**Breaks When**: Relying on specific values rather than truthiness.

**Before (2.x)**:
```surql
array::logical_or(["a"],[true]);  // returns ["a"]
array::logical_or([""],[false]);  // returns [""]
array::logical_or([],[false]);    // returns [NULL]
```

**After (3.x)**:
```surql
array::logical_or(["a"],[true]);  // returns ["a"]
array::logical_or([""],[false]);  // returns [false]
array::logical_or([false],[]);    // returns [NONE]
```

**Action**: Update if relying on specific return values; no change needed if only checking truthiness.


### 22. Mock Value Type Changes

**Severity**: Unlikely break

**What Changed**: Mocks now return arrays instead of special mock type.

**Breaks When**: Code depends on the specific mock type being returned.

**Before (2.x)**:
```surql
|a:1..2|;  // returns |a:1..2| (mock type)
type::is_array(|a:1..2|);  // returns false
```

**After (3.x)**:
```surql
|a:1..=2|;  // returns [a:1, a:2] (array)
type::is_array(|a:1..=2|);  // returns true
```

>[!NOTE]
>Mock ranges are no longer inclusive by default - use `..=` for inclusive ranges.
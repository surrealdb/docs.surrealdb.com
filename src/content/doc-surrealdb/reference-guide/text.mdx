---
sidebar_position: 6
sidebar_label: Working With Text
title: Working with text | Reference guides
description: SurrealDB offers a large variety of ways to work with text, including equality and contains operators, fuzzy searching, and full-text search.
---

# Working with text in SurrealDB

SurrealDB offers a large variety of ways to work with text, from simple operators to fuzzy searching, customized ordering, full-text search and more.

## Comparing and sorting text

### In `SELECT` queries

The following example shows a few records created from an array of strings in an order that is sorted to the human eye: lowest to highest numbers, then A to Z.

```surql
FOR $word IN ['1', '2', '11', '√Åbaco', 'kitty', 'Zoo'] {
	CREATE data SET val = $word;
};
```

Inside a `SELECT` query, an `ORDER BY` clause can be used to order the output by one or more field names. For the above data, an ordered `SELECT` query looks like this.

```surql
SELECT VALUE val FROM data ORDER BY val;
```

However, in the case of strings, sorting is done by Unicode rank which often leads to output that seems out of order to the human eye. The output of the above query shows the following:

```surql title="Output"
[ '1', '11', '2', 'Zoo', 'kitty', '√Åbaco' ]
```

This is because:

* '11' is ordered before '2', because the first character in the string '2' is greater than the first character in the string '1'.
* 'Zoo' is ordered before 'kitty', because the first character in the string 'Zoo' is 'Z', number 0059 in the [list of Unicode characters](https://en.wikipedia.org/wiki/List_of_Unicode_characters#Basic_Latin). A lowercase 'k' is 0076 on the list and thus "greater", while the '√Å', registered as the "Latin Capital letter A with acute", is 0129 on the list.

To sort strings in a more natural manner to the human eye, the keywords `NUMERIC` and `COLLATE` (or both) can be used. `NUMERIC` will instruct strings that parse into numbers to be treated as such.

```surql
SELECT VALUE val FROM data ORDER BY val NUMERIC;
```

```surql title="Numberic strings now sorted as numbers"
[ '1', '2', '11', 'Zoo', 'kitty', '√Åbaco' ]
```

`COLLATE` instructs unicode strings to sort by alphabetic order, rather than Unicode order.

```surql
SELECT VALUE val FROM data ORDER BY val COLLATE;
```

```surql title="Output"
[ '1', '11', '2', '√Åbaco', 'kitty', 'Zoo' ]
```

And for the data in this example, `COLLATE NUMERIC` is likely what will be desired.

```surql
SELECT VALUE val FROM data ORDER BY val COLLATE NUMERIC;
```

```surql title="Output"
[ '1', '2', '11', '√Åbaco', 'kitty', 'Zoo' ]
```

As of SurrealDB 2.2.2, the functions `array::sort_natural()`, `array::sort_lexical()`, and `array::sort_lexical_natural()` can be used on ad-hoc data to return the same output as the `COLLATE` and `NUMERIC` clauses in a `SELECT` statement.

## Contains

```surql
-- false
"Umple" IN "Rumplestiltskin";
"Rumplestiltskin".contains("Umple");
string::contains("Rumplestiltskin", "Umple");

-- true
"umple" IN "Rumplestiltskin";
"Rumplestiltskin".contains("umple");
string::contains("Rumplestiltskin", "umple");
```

SurrealDB has a number of operators to determine if all or some of the values of one array are contained in another, such as `CONTAINSALL` and `CONTAINSANY`, or `ALLINSIDE` and `ANYINSIDE`. The `CONTAINS` and `INSIDE` operators perform the same behaviour, just in the opposite order.

```surql
-- If 1,2,3 contains each item in 1,2
[1,2,3] CONTAINSALL [1,2];
-- then each item in 1,2 is inside 1,2,3
[1,2] ALLINSIDE [1,2,3];
```

Because strings are essentially arrays of characters, these operators work with strings as well. (Note: this capability was added in SurrealDB version 2.2.2)

Both of these queries will return `true`.

```surql
"Rumplestiltskin" CONTAINSALL ["umple", "kin"];
"kin" ALLINSIDE "Rumplestiltskin";
```

## Equality and fuzzy equality

While strings can be compared for strict equality in the same way as with other values, fuzzy searching can also be used to return `true` if two strings are approximately equal.

* `~` to check if two strings have fuzzy equality
* `!~` to check if two strings do not have fuzzy equality
* `?~` to check if any strings have fuzzy equality
* `*~` to check if all strings have fuzzy equality

All of the following will return true.

```surql
"big" ~ "Big";
"big" !~ "small";
["Big", "small"] ?~ "big";
["Big", "big"] *~ "big";
```

Fuzzy matching is based on [an algorithm](https://en.wikipedia.org/wiki/Smith%E2%80%93Waterman_algorithm) that requires some time to understand. It is a convenient option due to the `~` operator, but can sometimes produce surprising results.

```surql
 -- true
"United Kingdom" ~ "United kingdom";
-- true (second string entirely contained in first)
"United Kingdom" ~ "ited";
-- Also true!
"United Kingdom" ~ "i";
-- false
"United Kingdom" ~ "United Kingd√≥m";
```

The `string::similarity::fuzzy` function can be useful in this case, as it returns a number showing the similarity between strings, not just whether they count as a fuzzy match. In the following example, while the strings "ited" and "i" do have a similarity score above 0, they are ranked much lower than the better matches "United kingdom" and "United Kingdom".

```surql
LET $similarities = ["United Kingdom", "United kingdom", "ited", "United Kingd√≥m", "i"].map(|$string| {
    {
        word: $string,
        similarity: string::similarity::fuzzy("United Kingdom", $string)
    }
});
SELECT * FROM $similarities ORDER BY similarity DESC;
```

```surql title="Output"
[
	{
		similarity: 295,
		word: 'United Kingdom'
	},
	{
		similarity: 293,
		word: 'United kingdom'
	},
	{
		similarity: 75,
		word: 'ited'
	},
	{
		similarity: 15,
		word: 'i'
	},
	{
		similarity: 0,
		word: 'United Kingd√≥m'
	}
]
```

Also note that similarity and distance scores are not a measure of absolute equality and ordered similarity scores should only be used in comparisons against the same string. Take the following two queries for example which compare a single string against two different strings:

```surql
-- returns 131
string::similarity::fuzzy("United Kingdom", "United");
-- also returns 131
string::similarity::fuzzy("United", "United");
```

While "United" is clearly more similar to "United" than to "United Kingdom", the output of each one is 131. This number is generated from the point of view of the second "United" string, which finds an exact match for itself inside the first string.

## Other fuzzy match algorithms

SurrealDB offers quite a few other algorithms inside the [string functions module](/docs/surrealql/functions/database/string) for distance or similarity comparison. They are:

* `string::distance::damerau_levenshtein()`
* `string::distance::normalized_damerau_levenshtein()`
* `string::distance::hamming()`
* `string::distance::levenshtein()`
* `string::distance::normalized_levenshtein()`
* `string::distance::osa_distance()`

* `string::similarity::jaro()`
* `string::similarity::jaro_winkler()`

These resemble fuzzy searching to a certain extent, but have a different output and may have different requirements. For example, the Hamming distance algorithm was made for strings of equal length, so a query comparing "United Kingdom" to "United" will not work.

```surql
-- Error: strings have different length
string::distance::hamming("United Kingdom", "United");
-- Returns 0
string::distance::hamming("United", "United");
-- Returns 1
string::distance::hamming("United", "Unit√©d");
-- Returns 6
string::distance::hamming("United", "uNITED");
```

## Regex matching

The `string::matches` function can be used to perform regex matching on a string.

```surql
-- true
string::matches("Cat", "[HC]at");
-- Also true
string::matches("Hat", "[HC]at");
```

## Other string functions

SurrealDB has a large number of [string functions](/docs/surrealql/functions/database/string) that can be used manually to refine string searching, such as `string::lowercase()`, `string::starts_with()`, and `string::ends_with()`.

```surql
SELECT 
    $this AS word, 
    $this.lowercase() = "sleek" AS is_sleek
FROM ["sleek", "SLEEK", "Sleek", "sleeek"];
```

```surql title="Output"
[
	{
		is_sleek: true,
		word: 'sleek'
	},
	{
		is_sleek: true,
		word: 'SLEEK'
	},
	{
		is_sleek: true,
		word: 'Sleek'
	},
	{
		is_sleek: false,
		word: 'sleeek'
	}
]
```

For more customized text searching, full-text search can be used.

## Full-text search

Full-Text search supports text matching, proximity searches, result ranking, and keyword highlighting, making it a much more comprehensive solution when precise text searching is required.

It is also [ACID-compliant](https://en.wikipedia.org/wiki/ACID), which ensures data integrity and reliability.

### Defining an analyzer

The first step to using full-text search is to [define an analyzer](/docs/surrealql/statements/define/analyzer) using a `DEFINE ANALYZER` statement. An analyzer is not defined on a table, but a set of tokenizers (to break up text) and filters (to modify text).

The `DEFINE ANALYZER` page contains a detailed explanation of each type of tokenizer and analyzer to choose from. To define the analyzer that most suits your needs, it is recommended to use the [`search::analyze`](/docs/surrealql/functions/database/search#searchanalyze) function which returns the output of an analyzer for an input string.

Take the following analyzer for example, which uses `blank` to split a string by whitespace, and `edgengram(3, 10)` to output all of the instances of the first three to ten letters of a word.

```surql
DEFINE ANALYZER blank_edgengram TOKENIZERS blank FILTERS edgengram(3, 10);
search::analyze("blank_edgengram", "The Wheel of Time turns, and Ages come and pass, leaving memories that become legend.");
```

The output includes strings like 'turns,' and 'legend.', which include punctuation marks.

```surql title="Output"
['The', 'Whe', 'Whee', 'Wheel', 'Tim', 'Time', 'tur', 'turn', 'turns', 'turns,', 'and', 'Age', 'Ages', 'com', 'come', 'and', 'pas', 'pass', 'pass,', 'lea', 'leav', 'leavi', 'leavin', 'leaving', 'mem', 'memo', 'memor', 'memori', 'memorie', 'memories', 'tha', 'that', 'bec', 'beco', 'becom', 'become', 'leg', 'lege', 'legen', 'legend', 'legend.']
```

If this is not desired, some looking through the `DEFINE ANALYZER` page will turn up another tokenizer called `punct` that can be included, now creating an analyzer that splits on whitespace as well as punctuation. Since punctuation on its own will not 

```surql
DEFINE ANALYZER blank_edgengram TOKENIZERS blank, punct FILTERS edgengram(3, 10);
search::analyze("blank_edgengram", "The Wheel of Time turns, and Ages come and pass, leaving memories that become legend.");
```

```surql title="Output"
['The', 'Whe', 'Whee', 'Wheel', 'Tim', 'Time', 'tur', 'turn', 'turns', 'and', 'Age', 'Ages', 'com', 'come', 'and', 'pas', 'pass', 'lea', 'leav', 'leavi', 'leavin', 'leaving', 'mem', 'memo', 'memor', 'memori', 'memorie', 'memories', 'tha', 'that', 'bec', 'beco', 'becom', 'become', 'leg', 'lege', 'legen', 'legend']
```

#### Tokenizers and filters

* Tokenizers `blank`, `camel`, `punct` to split by whitespace, camelcase, and punctuation. The `class` tokenizer splits when a class change is detected, such as letter to number, space to letter, punctuation to letter, and so on.
* Filters `ascii`, `lowercase`, `uppercase` to change to ASCII, lowercase, and uppercase.

The `ngram` filter takes a minimum and maximum length, then moves from character to character inside a string as it attempts to find all the possible outputs in between these two lengths.

```surql
DEFINE ANALYZER example_analyzer FILTERS ngram(1,4);
search::analyze("example_analyzer", "cars!");
```

Here is the output modified slightly to show the output of the `ngram` filter at each step of the way.

```surql title="Output"
[
	'c', 'ca', 'car', 'cars',
	'a', 'ar', 'ars', 'ars!',
	'r', 'rs', 'rs!',
	's', 's!',
	'!'
]
```

Two tokenizers, `snowball` and `mapper`, warrant 

#### The snowball filter

The snowball filter is used to perform stemming: the reduction of a word to as basic and universal a form as possible. Stemming involves using an algorithm to reduce a word, but is unable to incorporate complex changes like the plural and verbal vowel changes in English.

```surql
DEFINE ANALYZER snowball_test TOKENIZERS blank,punct FILTERS snowball(english);
search::analyze("snowball_test", "
    manager managing management
    running ran 
    foot feet
    introspective
    introspection
    introspected
");
```

```surql title="Output"
[
	'manag',
	'manag',
	'manag',
	'run',
	'ran',
	'foot',
	'feet',
	'introspect',
	'introspect',
	'introspect'
]
```

Stemming is particularly useful in languages with complex but regular declension, such as Finnish. In the following example, the snowball filter is able to turn all declined forms of the word "talo" (house) into its root form.

```surql
DEFINE ANALYZER snowball_test TOKENIZERS blank,punct FILTERS snowball(finnish);
search::analyze("snowball_test", "talo talon taloa talossa talostani taloonsa talolla talolta talolle talona taloksi taloin talotta taloineen");
```

```surql title="Output"
['talo', 'talo', 'talo', 'talo', 'talo', 'talo', 'talo', 'talo', 'talo', 'talo', 'talo', 'talo', 'talot', 'talo']
```

The 

#### The mapper filter

The `mapper` filter is the most customizable of all, involving a list of strings and the strings they are to be mapped to. This filter requires a path to a text file, inside which each base form is followed by a word to map to it, separated by a comma.

```text title="mapper.txt"
run	ran
foot	feet
```

In the case of the above example, the `mapper` will allow the output to show the base forms of the words "ran" and "feet".

```surql
DEFINE ANALYZER mapper TOKENIZERS blank FILTERS snowball(english),mapper('mapper.txt');
search::analyze("mapper", "
    manager managing management
    running ran 
    foot feet
    introspective
    introspection
    introspected
");
```

```surql
[
	'manag',
	'manag',
	'manag',
	'run',
	'run',
	'foot',
	'foot',
	'introspect',
	'introspect',
	'introspect'
]
```

The word `mapper` was intentionally chosen to be ambiguous, as this feature can be used to map any string to another string.

```text title="mapper.txt"
seated_man	ìÄÄ
man_with_hand_to_mouth	ìÄÅ
seated_woman	ìÅê
goddess_with_feather	ìÅ¶
```

```surql
DEFINE ANALYZER mapper TOKENIZERS blank FILTERS mapper('mapper.txt');
search::analyze("mapper", "ìÄÄ ìÅ¶");
```

```surql title="Output"
[
	'seated_man',
	'goddess_with_feather'
]
```

{/* ```text title="mapper.txt"
happy	üòä
happy	üòÑ
amused	üòè
amused	üòÅ
amused	üòÑ
``` */}

### Define a Full-Text Index

Once a search analyzer is defined, it can be applied to the fields of a table to make them searchable by [defining an index](/docs/surrealql/statements/define/indexes#full-text-search-index) along with the `SEARCH ANALYZER` clause.

Depending on the use case, each field or column can be associated with a different analyzers
To enable text highlight on searches, use the `HIGHLIGHTS` keyword when defining a full-text search index. This enables you use the [`search::highlight`](/docs/surrealql/functions/database/search#searchhighlight) function. 

```surql
-- Defining two full-text indexes on the 'title' and 'content' field of the 'book' table
DEFINE INDEX book_title ON book FIELDS title SEARCH ANALYZER custom_analyzer BM25;
DEFINE INDEX book_content ON book FIELDS content SEARCH ANALYZER custom_analyzer BM25 HIGHLIGHTS;
```

### The MATCHES Operator
To find documents that contain the given keywords based on the full-text indexes, the [matches](/docs/surrealql/operators#matches) operator (@@) is used in queries. 

```surql
-- Using the MATCHES (@@) operator in a query
SELECT * FROM book WHERE content @@ 'tools';
```

### Search Functions
If you want to do more with your search results, SurrealDB offers 3 search functions that accompany the matches operator.
- [`search::highlight`](/docs/surrealql/functions/database/search#searchhighlight): Highlights the matching keywords for the predicate reference number.
- [`search::offsets`](/docs/surrealql/functions/database/search#searchoffsets): Returns the position of the matching keywords for the predicate reference number.
- [`search::score`](/docs/surrealql/functions/database/search#searchscore): Helps with scoring and ranking the search results based on their relevance to the search terms.


